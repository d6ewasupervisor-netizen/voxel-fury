<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>VOXEL FURY v2 | Core Engine</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        html, body {
            width: 100%; height: 100%;
            overflow: hidden;
            background: #1a0a2e;
            touch-action: none;
            user-select: none;
            -webkit-user-select: none;
            -webkit-touch-callout: none;
            -webkit-tap-highlight-color: transparent;
        }
        #canvas { position: fixed; inset: 0; width: 100%; height: 100%; }

        /* HUD */
        #hud {
            position: fixed;
            top: 8px; left: 8px;
            color: #0ff;
            font: bold 14px monospace;
            text-shadow: 0 0 10px #0ff;
            z-index: 100;
            pointer-events: none;
        }
        #hud div { margin: 3px 0; }

        /* Bottom control bar: steering left, pedals right */
        #control-bar {
            position: fixed;
            bottom: 0; left: 0; right: 0;
            height: 45vh;
            display: flex;
            z-index: 50;
        }

        /* Steering on the left half */
        #steer-zone {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        #steer-indicator {
            width: 180px;
            height: 60px;
            background: rgba(0,255,255,0.1);
            border: 2px solid #0ff;
            border-radius: 30px;
            position: relative;
        }
        #steer-thumb {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 40px;
            height: 40px;
            background: #0ff;
            border-radius: 50%;
            box-shadow: 0 0 20px #0ff;
            transition: left 0.05s;
        }

        /* Pedals on the right half */
        #controls {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 12px;
        }
        .control-zone {
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .pedal {
            width: 80px;
            height: 120px;
            border-radius: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            font: bold 16px monospace;
            color: white;
            text-shadow: 0 0 5px currentColor;
            opacity: 0.7;
            transition: opacity 0.1s, transform 0.1s;
        }
        .pedal.active { opacity: 1; transform: scale(1.1); }
        #brake { background: rgba(255,50,50,0.4); border: 2px solid #f55; }
        #gas { background: rgba(50,255,50,0.4); border: 2px solid #5f5; }

        /* Reset button (mobile) */
        #reset-btn {
            position: fixed;
            top: 8px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 100;
            background: rgba(255,100,0,0.5);
            border: 2px solid #f64;
            color: #fff;
            font: bold 12px monospace;
            padding: 6px 14px;
            border-radius: 6px;
            display: none;
            cursor: pointer;
        }
        #reset-btn:active { background: rgba(255,100,0,0.8); }

        /* Fullscreen prompt */
        #fullscreen-prompt {
            position: fixed;
            inset: 0;
            background: rgba(0,0,0,0.85);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 200;
            flex-direction: column;
            gap: 16px;
        }
        #fullscreen-prompt span {
            color: #0ff;
            font: bold 18px monospace;
            text-shadow: 0 0 10px #0ff;
            text-align: center;
            padding: 0 20px;
        }
        #fullscreen-prompt button {
            background: rgba(0,255,255,0.3);
            border: 2px solid #0ff;
            color: #fff;
            font: bold 16px monospace;
            padding: 12px 32px;
            border-radius: 8px;
            cursor: pointer;
        }
        #fullscreen-prompt button:active { background: rgba(0,255,255,0.6); }

        /* Orientation warning */
        #orientation-warning {
            position: fixed;
            inset: 0;
            background: rgba(0,0,0,0.9);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 300;
            flex-direction: column;
            gap: 12px;
        }
        #orientation-warning span {
            color: #0ff;
            font: bold 16px monospace;
            text-shadow: 0 0 10px #0ff;
            text-align: center;
            padding: 0 20px;
        }
        #orientation-warning .rotate-icon {
            font-size: 48px;
            animation: rotateHint 2s ease-in-out infinite;
        }
        @keyframes rotateHint {
            0%, 100% { transform: rotate(0deg); }
            50% { transform: rotate(90deg); }
        }

        /* Responsive: small phones */
        @media (max-width: 480px) {
            #hud { font-size: 11px; top: 4px; left: 4px; }
            #hud div { margin: 2px 0; }
            #minimap { width: 80px !important; height: 80px !important; }
            .pedal { width: 58px; height: 80px; font-size: 12px; }
            #steer-indicator { width: 130px; height: 44px; }
            #steer-thumb { width: 30px; height: 30px; }
            #controls { gap: 6px; }
        }

        /* Responsive: landscape phones */
        @media (max-height: 500px) and (orientation: landscape) {
            #control-bar { height: 50vh; }
            .pedal { width: 66px; height: 74px; font-size: 12px; }
            #hud { font-size: 11px; }
            #hud div { margin: 1px 0; }
            #minimap { width: 80px !important; height: 80px !important; top: 4px !important; right: 4px !important; }
        }

        /* Responsive: tablets */
        @media (min-width: 768px) and (max-width: 1024px) {
            .pedal { width: 100px; height: 140px; font-size: 18px; }
            #steer-indicator { width: 260px; height: 70px; }
            #steer-thumb { width: 50px; height: 50px; }
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    
    <div id="hud">
        <div>SPEED: <span id="speed">0</span> mph</div>
        <div>RPM: <span id="rpm">0</span></div>
        <div>GEAR: <span id="gear">1</span></div>
        <div>FPS: <span id="fps">0</span></div>
        <div id="drift-indicator" style="display:none; color:#ff0; margin-top:10px;">‚ö° DRIFT!</div>
        <div id="handbrake-indicator" style="display:none; color:#f55; margin-top:5px;">üÖøÔ∏è HANDBRAKE</div>
        <div style="margin-top:10px;">
            <div style="font-size:12px; color:#0ff;">NITRO</div>
            <div style="width:100px; height:12px; background:#333; border:1px solid #0ff; border-radius:3px;">
                <div id="nitro-bar" style="width:100%; height:100%; background:linear-gradient(90deg, #0ff, #f0f); border-radius:2px; transition:width 0.1s;"></div>
            </div>
        </div>
    </div>
    
    <canvas id="minimap" width="120" height="120" style="position:fixed; top:10px; right:10px; border:2px solid #0ff; border-radius:8px; background:rgba(0,0,0,0.6); z-index:100;"></canvas>

    <button id="reset-btn">RESET</button>

    <div id="fullscreen-prompt">
        <span>Tap to play fullscreen</span>
        <button id="fs-btn">PLAY</button>
    </div>

    <div id="orientation-warning">
        <div class="rotate-icon">&#x21BB;</div>
        <span>Rotate your device to landscape for the best experience</span>
    </div>

    <div id="control-bar">
        <div id="steer-zone">
            <div id="steer-indicator">
                <div id="steer-thumb"></div>
            </div>
        </div>
        <div id="controls">
            <div class="control-zone">
                <div id="brake" class="pedal">BRAKE</div>
            </div>
            <div class="control-zone" style="flex-direction:column; gap:10px;">
                <div id="nitro" class="pedal" style="width:70px; height:50px; background:rgba(0,255,255,0.3); border-color:#0ff;">N2O</div>
                <div id="handbrake" class="pedal" style="width:70px; height:50px; background:rgba(255,100,0,0.3); border-color:#f64;">HB</div>
            </div>
            <div class="control-zone">
                <div id="gas" class="pedal">GAS</div>
            </div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
    (function() {
        'use strict';

        // ============================================
        // MOBILE DETECTION & ADAPTIVE QUALITY
        // ============================================
        const isTouchDevice = 'ontouchstart' in window || navigator.maxTouchPoints > 0;
        const isMobile = isTouchDevice && (window.innerWidth <= 1024 || /Mobi|Android|iPhone|iPad|iPod/i.test(navigator.userAgent));
        const isLowEnd = isMobile && (navigator.hardwareConcurrency ? navigator.hardwareConcurrency <= 4 : true);

        // Adaptive quality settings
        const QUALITY = {
            pixelRatio: isLowEnd ? Math.min(window.devicePixelRatio, 1.5) : Math.min(window.devicePixelRatio, 2),
            ringSegments: isLowEnd ? 32 : 64,
            innerRingSegments: isLowEnd ? 24 : 48,
            treeSegments: isLowEnd ? 6 : 8,
            wheelSegments: isLowEnd ? 8 : 16,
            smokeSegments: isLowEnd ? 4 : 6,
            maxSmoke: isLowEnd ? 20 : 50,
            fogNear: isLowEnd ? 80 : 100,
            fogFar: isLowEnd ? 350 : 500,
            shadowsEnabled: false, // off for mobile perf
        };

        // ============================================
        // CONFIGURATION
        // ============================================
        const CONFIG = {
            physics: {
                tickRate: isLowEnd ? 60 : 120,
                maxSubSteps: isLowEnd ? 2 : 4
            },
            vehicle: {
                mass: 1200,
                power: 280,
                maxRPM: 7500,
                idleRPM: 900,
                brakeForce: 15000,
                handbrakeForce: 12000,
                dragCoeff: 0.35,
                rollingResistance: 0.015,
                maxSteerAngle: 0.45,
                wheelbase: 2.5
            },
            nitro: {
                powerMult: 1.8,         // Power multiplier when active
                maxAmount: 100,         // Max nitro tank
                useRate: 40,            // Depletion per second when active
                rechargeRate: 8,        // Recharge per second when not active
                minToActivate: 10       // Minimum amount needed to activate
            },
            tire: {
                B: 10, C: 1.9, D: 1.0, E: 0.97,
                gripCoeff: 1.1
            },
            gears: [3.2, 2.1, 1.4, 1.0, 0.8, 0.65],
            finalDrive: 3.7
        };
        
        // ============================================
        // GAME STATE
        // ============================================
        const state = {
            position: { x: 0, y: 0, z: 0 },
            velocity: { x: 0, y: 0, z: 0 },
            rotation: 0,
            angularVelocity: 0,
            speed: 0,
            lateralSpeed: 0,
            rpm: CONFIG.vehicle.idleRPM,
            gear: 1,
            isDrifting: false,
            driftAngle: 0,
            
            prevPosition: { x: 0, y: 0, z: 0 },
            prevRotation: 0,
            
            // Input
            throttle: 0,
            brake: 0,
            steering: 0,
            handbrake: 0,
            nitroActive: false,
            reversing: false,
            
            // Nitro system
            nitroAmount: CONFIG.nitro.maxAmount,
            
            // Timing
            lastTime: 0,
            accumulator: 0,
            frameCount: 0,
            physicsCount: 0,
            lastFPSUpdate: 0
        };
        
        // ============================================
        // THREE.JS SETUP
        // ============================================
        const canvas = document.getElementById('canvas');
        const renderer = new THREE.WebGLRenderer({ canvas, antialias: !isLowEnd, powerPreference: isMobile ? 'high-performance' : 'default' });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(QUALITY.pixelRatio);
        renderer.setClearColor(0x1a0a2e);

        const scene = new THREE.Scene();
        scene.fog = new THREE.Fog(0x1a0a2e, QUALITY.fogNear, QUALITY.fogFar);
        
        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
        
        // Lighting
        const ambientLight = new THREE.AmbientLight(0x404060, 0.5);
        scene.add(ambientLight);
        
        const sunLight = new THREE.DirectionalLight(0xffffff, 1);
        sunLight.position.set(50, 100, 50);
        scene.add(sunLight);
        
        // Ground plane
        const groundGeo = new THREE.PlaneGeometry(800, 800);
        const groundMat = new THREE.MeshStandardMaterial({ 
            color: 0x1a1a2a,
            roughness: 0.9
        });
        const ground = new THREE.Mesh(groundGeo, groundMat);
        ground.rotation.x = -Math.PI / 2;
        ground.position.y = 0;
        scene.add(ground);
        
        // Grid for reference
        const gridHelper = new THREE.GridHelper(800, 80, 0x333355, 0x222233);
        scene.add(gridHelper);
        
        // ============================================
        // TRACK SYSTEM
        // ============================================
        const trackMat = new THREE.MeshStandardMaterial({ color: 0x333344, roughness: 0.7 });
        const lineMat = new THREE.MeshBasicMaterial({ color: 0xffff00 });
        const edgeMat = new THREE.MeshBasicMaterial({ color: 0xff3333 });
        
        // Outer oval track
        const outerTrack = new THREE.RingGeometry(140, 170, QUALITY.ringSegments);
        const outerRoad = new THREE.Mesh(outerTrack, trackMat);
        outerRoad.rotation.x = -Math.PI / 2;
        outerRoad.position.y = 0.01;
        scene.add(outerRoad);

        // Outer track center line
        const outerLine = new THREE.RingGeometry(154, 156, QUALITY.ringSegments);
        const outerCenterLine = new THREE.Mesh(outerLine, lineMat);
        outerCenterLine.rotation.x = -Math.PI / 2;
        outerCenterLine.position.y = 0.02;
        scene.add(outerCenterLine);

        // Inner oval track
        const innerTrack = new THREE.RingGeometry(50, 80, QUALITY.innerRingSegments);
        const innerRoad = new THREE.Mesh(innerTrack, trackMat);
        innerRoad.rotation.x = -Math.PI / 2;
        innerRoad.position.y = 0.01;
        scene.add(innerRoad);

        // Inner track center line
        const innerLine = new THREE.RingGeometry(64, 66, QUALITY.innerRingSegments);
        const innerCenterLine = new THREE.Mesh(innerLine, lineMat);
        innerCenterLine.rotation.x = -Math.PI / 2;
        innerCenterLine.position.y = 0.02;
        scene.add(innerCenterLine);
        
        // Connecting roads (straights between inner and outer)
        const connectGeo = new THREE.PlaneGeometry(30, 65);
        const connectPositions = [
            { x: 0, z: 110, rot: 0 },
            { x: 0, z: -110, rot: 0 },
            { x: 110, z: 0, rot: Math.PI / 2 },
            { x: -110, z: 0, rot: Math.PI / 2 }
        ];
        
        connectPositions.forEach(pos => {
            const road = new THREE.Mesh(connectGeo, trackMat);
            road.rotation.x = -Math.PI / 2;
            road.rotation.z = pos.rot;
            road.position.set(pos.x, 0.01, pos.z);
            scene.add(road);
        });
        
        // ============================================
        // BUILDINGS (with collision)
        // ============================================
        const buildings = [];
        const buildingMat = new THREE.MeshStandardMaterial({ 
            color: 0x445566, 
            roughness: 0.8,
            metalness: 0.2
        });
        const buildingGlowMat = new THREE.MeshBasicMaterial({ color: 0x00ffff });
        
        const buildingPositions = [
            // Outer corners
            { x: 200, z: 200, w: 30, h: 45, d: 30 },
            { x: -200, z: 200, w: 25, h: 60, d: 35 },
            { x: 200, z: -200, w: 35, h: 50, d: 25 },
            { x: -200, z: -200, w: 28, h: 55, d: 28 },
            // Mid positions
            { x: 250, z: 0, w: 40, h: 70, d: 30 },
            { x: -250, z: 0, w: 35, h: 65, d: 35 },
            { x: 0, z: 250, w: 30, h: 40, d: 40 },
            { x: 0, z: -250, w: 45, h: 80, d: 25 },
            // Inner area (center)
            { x: 0, z: 0, w: 20, h: 35, d: 20 },
            // Additional scattered
            { x: 180, z: 100, w: 20, h: 30, d: 20 },
            { x: -180, z: -100, w: 25, h: 45, d: 20 },
            { x: 100, z: -180, w: 22, h: 38, d: 22 },
            { x: -100, z: 180, w: 18, h: 42, d: 24 }
        ];
        
        buildingPositions.forEach(b => {
            const geo = new THREE.BoxGeometry(b.w, b.h, b.d);
            const mesh = new THREE.Mesh(geo, buildingMat);
            mesh.position.set(b.x, b.h / 2, b.z);
            scene.add(mesh);
            
            // Glow strip on buildings
            const stripGeo = new THREE.BoxGeometry(b.w + 0.5, 1, b.d + 0.5);
            const strip = new THREE.Mesh(stripGeo, buildingGlowMat);
            strip.position.set(b.x, b.h * 0.7, b.z);
            scene.add(strip);
            
            // Store for collision
            buildings.push({
                x: b.x, z: b.z,
                hw: b.w / 2 + 2,  // half-width + buffer
                hd: b.d / 2 + 2   // half-depth + buffer
            });
        });
        
        // ============================================
        // TREES (scenery, with collision)
        // ============================================
        const trees = [];
        const trunkMat = new THREE.MeshStandardMaterial({ color: 0x4a3728 });
        const leafMat = new THREE.MeshStandardMaterial({ color: 0x2d5a27 });
        
        const treePositions = [
            // Scattered around outer edge
            { x: 280, z: 150 }, { x: 300, z: -50 }, { x: -280, z: 100 },
            { x: -300, z: -120 }, { x: 150, z: 280 }, { x: -100, z: 300 },
            { x: 50, z: -290 }, { x: -150, z: -280 },
            // Between tracks
            { x: 100, z: 100 }, { x: -100, z: 100 }, { x: 100, z: -100 }, { x: -100, z: -100 },
            { x: 120, z: 50 }, { x: -120, z: -50 }, { x: 50, z: 120 }, { x: -50, z: -120 }
        ];
        
        treePositions.forEach(pos => {
            // Trunk
            const trunkGeo = new THREE.CylinderGeometry(0.8, 1.2, 6, QUALITY.treeSegments);
            const trunk = new THREE.Mesh(trunkGeo, trunkMat);
            trunk.position.set(pos.x, 3, pos.z);
            scene.add(trunk);

            // Leaves (cone)
            const leafGeo = new THREE.ConeGeometry(4, 10, QUALITY.treeSegments);
            const leaves = new THREE.Mesh(leafGeo, leafMat);
            leaves.position.set(pos.x, 11, pos.z);
            scene.add(leaves);
            
            // Collision (circular)
            trees.push({ x: pos.x, z: pos.z, r: 2 });
        });
        
        // ============================================
        // COLLISION DETECTION
        // ============================================
        function checkCollisions() {
            const carX = state.position.x;
            const carZ = state.position.z;
            const carRadius = 2.5;
            
            // Check buildings (AABB)
            for (const b of buildings) {
                const dx = Math.abs(carX - b.x);
                const dz = Math.abs(carZ - b.z);
                
                if (dx < b.hw + carRadius && dz < b.hd + carRadius) {
                    // Collision! Push car out and reduce speed
                    const overlapX = b.hw + carRadius - dx;
                    const overlapZ = b.hd + carRadius - dz;
                    
                    if (overlapX < overlapZ) {
                        state.position.x += overlapX * Math.sign(carX - b.x);
                        state.velocity.x *= -0.3;
                    } else {
                        state.position.z += overlapZ * Math.sign(carZ - b.z);
                        state.velocity.z *= -0.3;
                    }
                    state.speed *= 0.5;
                    return true;
                }
            }
            
            // Check trees (circle)
            for (const t of trees) {
                const dx = carX - t.x;
                const dz = carZ - t.z;
                const dist = Math.sqrt(dx * dx + dz * dz);
                
                if (dist < t.r + carRadius) {
                    // Push out
                    const overlap = t.r + carRadius - dist;
                    const nx = dx / dist;
                    const nz = dz / dist;
                    state.position.x += nx * overlap;
                    state.position.z += nz * overlap;
                    state.velocity.x *= -0.2;
                    state.velocity.z *= -0.2;
                    state.speed *= 0.4;
                    return true;
                }
            }
            
            return false;
        }
        
        // ============================================
        // VEHICLE MODEL - Pink VW Bug with Mud Tires & Plow
        // ============================================
        const carGroup = new THREE.Group();
        const pinkMat = new THREE.MeshStandardMaterial({ color: 0xff69b4, metalness: 0.4, roughness: 0.35 });
        const darkPinkMat = new THREE.MeshStandardMaterial({ color: 0xd4507a, metalness: 0.3, roughness: 0.4 });
        const chromeMat = new THREE.MeshStandardMaterial({ color: 0xcccccc, metalness: 0.9, roughness: 0.1 });
        const glassMat = new THREE.MeshStandardMaterial({ color: 0x88ccff, metalness: 0.8, roughness: 0.1, transparent: true, opacity: 0.6 });
        const tireMat = new THREE.MeshStandardMaterial({ color: 0x1a1a1a, roughness: 0.95 });
        const rimMat = new THREE.MeshStandardMaterial({ color: 0xaaaaaa, metalness: 0.8, roughness: 0.2 });
        const plowMat = new THREE.MeshStandardMaterial({ color: 0x888888, metalness: 0.7, roughness: 0.3 });

        // --- Main body (lower box, slightly rounded via wider center) ---
        const bodyGeo = new THREE.BoxGeometry(2.2, 0.7, 4.2);
        const body = new THREE.Mesh(bodyGeo, pinkMat);
        body.position.y = 0.65;
        carGroup.add(body);

        // --- Rounded roof / cabin (VW Bug dome shape) ---
        const roofGeo = new THREE.SphereGeometry(1.15, 12, 8, 0, Math.PI * 2, 0, Math.PI * 0.5);
        const roof = new THREE.Mesh(roofGeo, pinkMat);
        roof.scale.set(0.85, 0.6, 0.9);
        roof.position.set(0, 1.0, -0.3);
        carGroup.add(roof);

        // --- Rear engine hump (VW Bug signature) ---
        const rearHumpGeo = new THREE.SphereGeometry(0.9, 10, 8, 0, Math.PI * 2, 0, Math.PI * 0.5);
        const rearHump = new THREE.Mesh(rearHumpGeo, pinkMat);
        rearHump.scale.set(1.0, 0.45, 0.8);
        rearHump.position.set(0, 0.95, -1.7);
        carGroup.add(rearHump);

        // --- Front hood hump (VW Bug trunk) ---
        const frontHumpGeo = new THREE.SphereGeometry(0.85, 10, 8, 0, Math.PI * 2, 0, Math.PI * 0.5);
        const frontHump = new THREE.Mesh(frontHumpGeo, pinkMat);
        frontHump.scale.set(1.0, 0.4, 0.7);
        frontHump.position.set(0, 0.95, 1.4);
        carGroup.add(frontHump);

        // --- Fenders (4 wheel arches, beefy for mud tires) ---
        const fenderGeo = new THREE.SphereGeometry(0.55, 8, 6, 0, Math.PI, 0, Math.PI * 0.5);
        const fenderPositions = [
            { x: -1.15, z: 1.2 }, { x: 1.15, z: 1.2 },
            { x: -1.15, z: -1.2 }, { x: 1.15, z: -1.2 }
        ];
        fenderPositions.forEach(fp => {
            const fender = new THREE.Mesh(fenderGeo, darkPinkMat);
            fender.scale.set(1.0, 1.1, 1.3);
            fender.position.set(fp.x, 0.7, fp.z);
            fender.rotation.y = fp.x < 0 ? -Math.PI / 2 : Math.PI / 2;
            carGroup.add(fender);
        });

        // --- Windshield (two-piece VW style, angled) ---
        const windshieldGeo = new THREE.PlaneGeometry(1.5, 0.7);
        const windshield = new THREE.Mesh(windshieldGeo, glassMat);
        windshield.position.set(0, 1.25, 0.55);
        windshield.rotation.x = -0.35;
        carGroup.add(windshield);

        // --- Rear window (small oval-ish) ---
        const rearWindowGeo = new THREE.PlaneGeometry(1.2, 0.5);
        const rearWindow = new THREE.Mesh(rearWindowGeo, glassMat);
        rearWindow.position.set(0, 1.2, -1.05);
        rearWindow.rotation.x = 0.4;
        rearWindow.rotation.y = Math.PI;
        carGroup.add(rearWindow);

        // --- Running boards (side trim) ---
        const runBoardGeo = new THREE.BoxGeometry(0.15, 0.1, 2.8);
        [-1.1, 1.1].forEach(x => {
            const board = new THREE.Mesh(runBoardGeo, chromeMat);
            board.position.set(x, 0.35, 0);
            carGroup.add(board);
        });

        // --- Bumpers (chrome, front and rear) ---
        const bumperGeo = new THREE.BoxGeometry(2.0, 0.15, 0.12);
        const frontBumper = new THREE.Mesh(bumperGeo, chromeMat);
        frontBumper.position.set(0, 0.4, 2.15);
        carGroup.add(frontBumper);
        const rearBumper = new THREE.Mesh(bumperGeo, chromeMat);
        rearBumper.position.set(0, 0.4, -2.15);
        carGroup.add(rearBumper);

        // --- Beefy Mud Tires (oversized with visible tread hubs) ---
        const tireRadius = 0.5;
        const tireWidth = 0.45;
        const tireGeo = new THREE.CylinderGeometry(tireRadius, tireRadius, tireWidth, QUALITY.wheelSegments);
        const rimGeo = new THREE.CylinderGeometry(0.2, 0.2, tireWidth + 0.02, QUALITY.wheelSegments);
        // Tread rings for beefy look
        const treadGeo = new THREE.TorusGeometry(tireRadius, 0.06, 4, QUALITY.wheelSegments);
        const treadMat = new THREE.MeshStandardMaterial({ color: 0x2a2a2a, roughness: 0.95 });

        const wheelPositions = [
            { x: -1.2, y: tireRadius, z: 1.3 },
            { x: 1.2, y: tireRadius, z: 1.3 },
            { x: -1.2, y: tireRadius, z: -1.3 },
            { x: 1.2, y: tireRadius, z: -1.3 }
        ];

        wheelPositions.forEach(pos => {
            const wheelGroup = new THREE.Group();
            // Main tire
            const tire = new THREE.Mesh(tireGeo, tireMat);
            tire.rotation.z = Math.PI / 2;
            wheelGroup.add(tire);
            // Rim
            const rim = new THREE.Mesh(rimGeo, rimMat);
            rim.rotation.z = Math.PI / 2;
            wheelGroup.add(rim);
            // Tread rings (3 rings for chunky look)
            [-0.12, 0, 0.12].forEach(offset => {
                const tread = new THREE.Mesh(treadGeo, treadMat);
                tread.rotation.y = Math.PI / 2;
                tread.position.x = offset;
                wheelGroup.add(tread);
            });
            wheelGroup.position.set(pos.x, pos.y, pos.z);
            carGroup.add(wheelGroup);
        });

        // --- Headlights (round, VW Bug style) ---
        const headlightGeo = new THREE.SphereGeometry(0.18, 8, 8);
        const headlightMat = new THREE.MeshBasicMaterial({ color: 0xffffaa });
        [-0.7, 0.7].forEach(x => {
            const hl = new THREE.Mesh(headlightGeo, headlightMat);
            hl.position.set(x, 0.75, 2.1);
            carGroup.add(hl);
            // Chrome ring around headlight
            const ringGeo = new THREE.TorusGeometry(0.2, 0.03, 6, 12);
            const ring = new THREE.Mesh(ringGeo, chromeMat);
            ring.position.set(x, 0.75, 2.12);
            carGroup.add(ring);
        });

        // --- Taillights (small, red, round) ---
        const taillightGeo = new THREE.SphereGeometry(0.12, 6, 6);
        const tailMat = new THREE.MeshBasicMaterial({ color: 0xff0000 });
        [-0.7, 0.7].forEach(x => {
            const tl = new THREE.Mesh(taillightGeo, tailMat);
            tl.position.set(x, 0.65, -2.12);
            carGroup.add(tl);
        });

        // --- SNOW PLOW (front-mounted) ---
        // Plow blade (angled wedge shape)
        const plowShape = new THREE.Shape();
        plowShape.moveTo(-1.6, 0);
        plowShape.lineTo(1.6, 0);
        plowShape.lineTo(1.4, 0.8);
        plowShape.lineTo(-1.4, 0.8);
        plowShape.closePath();
        const plowExtrudeSettings = { depth: 0.12, bevelEnabled: false };
        const plowBladeGeo = new THREE.ExtrudeGeometry(plowShape, plowExtrudeSettings);
        const plowBlade = new THREE.Mesh(plowBladeGeo, plowMat);
        plowBlade.position.set(0, 0.05, 2.55);
        plowBlade.rotation.x = -0.15;
        carGroup.add(plowBlade);

        // Plow reinforcement strip (bright yellow)
        const plowStripGeo = new THREE.BoxGeometry(3.0, 0.1, 0.08);
        const plowStripMat = new THREE.MeshBasicMaterial({ color: 0xffcc00 });
        const plowStrip = new THREE.Mesh(plowStripGeo, plowStripMat);
        plowStrip.position.set(0, 0.82, 2.58);
        carGroup.add(plowStrip);

        // Plow mounting arms (connect blade to body)
        const armGeo = new THREE.BoxGeometry(0.1, 0.12, 0.7);
        [-0.6, 0.6].forEach(x => {
            const arm = new THREE.Mesh(armGeo, chromeMat);
            arm.position.set(x, 0.45, 2.35);
            arm.rotation.x = -0.2;
            carGroup.add(arm);
        });

        // Center hydraulic arm
        const hydGeo = new THREE.CylinderGeometry(0.06, 0.06, 0.8, 6);
        const hydArm = new THREE.Mesh(hydGeo, chromeMat);
        hydArm.position.set(0, 0.5, 2.3);
        hydArm.rotation.x = Math.PI / 2 - 0.15;
        carGroup.add(hydArm);
        
        // Position car on outer track
        state.position.x = 155;
        state.position.z = 0;
        state.rotation = Math.PI / 2;
        state.prevPosition.x = state.position.x;
        state.prevPosition.z = state.position.z;
        state.prevRotation = state.rotation;
        
        carGroup.position.set(state.position.x, 0, state.position.z);
        carGroup.rotation.y = state.rotation;
        scene.add(carGroup);
        
        // ============================================
        // TIRE SMOKE PARTICLES
        // ============================================
        const smokeParticles = [];
        const maxSmokeParticles = QUALITY.maxSmoke;
        const smokeGeo = new THREE.SphereGeometry(0.3, QUALITY.smokeSegments, QUALITY.smokeSegments);
        const smokeMat = new THREE.MeshBasicMaterial({ 
            color: 0xcccccc, 
            transparent: true, 
            opacity: 0.6 
        });
        
        function spawnSmoke(x, z) {
            if (smokeParticles.length >= maxSmokeParticles) {
                const old = smokeParticles.shift();
                scene.remove(old);
            }
            const smoke = new THREE.Mesh(smokeGeo, smokeMat.clone());
            smoke.position.set(x, 0.2, z);
            smoke.userData = { life: 1.0, scale: 0.3 };
            scene.add(smoke);
            smokeParticles.push(smoke);
        }
        
        function updateSmoke(dt) {
            for (let i = smokeParticles.length - 1; i >= 0; i--) {
                const p = smokeParticles[i];
                p.userData.life -= dt * 0.8;
                p.userData.scale += dt * 1.5;
                p.scale.setScalar(p.userData.scale);
                p.material.opacity = p.userData.life * 0.5;
                p.position.y += dt * 0.5;
                
                if (p.userData.life <= 0) {
                    scene.remove(p);
                    smokeParticles.splice(i, 1);
                }
            }
            
            // Spawn smoke when drifting (less frequent on mobile)
            const smokeChance = isLowEnd ? 0.7 : 0.5;
            if (state.isDrifting && Math.random() > smokeChance) {
                const rearOffsetZ = -1.2;
                const cosR = Math.cos(state.rotation);
                const sinR = Math.sin(state.rotation);
                
                // Rear wheel positions
                [-0.9, 0.9].forEach(xOff => {
                    const wx = state.position.x + xOff * cosR + rearOffsetZ * sinR;
                    const wz = state.position.z - xOff * sinR + rearOffsetZ * cosR;
                    spawnSmoke(wx + (Math.random() - 0.5), wz + (Math.random() - 0.5));
                });
            }
        }
        
        // ============================================
        // INPUT HANDLING
        // ============================================
        const gasBtn = document.getElementById('gas');
        const brakeBtn = document.getElementById('brake');
        const handbrakeBtn = document.getElementById('handbrake');
        const nitroBtn = document.getElementById('nitro');
        const steerThumb = document.getElementById('steer-thumb');
        const steerZone = document.getElementById('steer-zone');
        const resetBtn = document.getElementById('reset-btn');
        const fullscreenPrompt = document.getElementById('fullscreen-prompt');
        const fsBtn = document.getElementById('fs-btn');
        const orientationWarning = document.getElementById('orientation-warning');

        let steerTouchId = null;
        let steerStartX = 0;

        // Hide on-screen controls on non-touch devices
        if (!isTouchDevice) {
            document.getElementById('control-bar').style.display = 'none';
        }

        // Haptic feedback helper
        function vibrate(ms) {
            if (isMobile && navigator.vibrate) {
                navigator.vibrate(ms);
            }
        }

        // Touch events for pedals
        function handlePedalStart(e, type) {
            e.preventDefault();
            if (type === 'gas') state.throttle = 1;
            if (type === 'brake') state.brake = 1;
            if (type === 'handbrake') state.handbrake = 1;
            if (type === 'nitro') state.nitroActive = true;
            e.target.classList.add('active');
            vibrate(15);
        }

        function handlePedalEnd(e, type) {
            e.preventDefault();
            if (type === 'gas') state.throttle = 0;
            if (type === 'brake') state.brake = 0;
            if (type === 'handbrake') state.handbrake = 0;
            if (type === 'nitro') state.nitroActive = false;
            e.target.classList.remove('active');
        }
        
        gasBtn.addEventListener('touchstart', e => handlePedalStart(e, 'gas'));
        gasBtn.addEventListener('touchend', e => handlePedalEnd(e, 'gas'));
        gasBtn.addEventListener('touchcancel', e => handlePedalEnd(e, 'gas'));
        
        brakeBtn.addEventListener('touchstart', e => handlePedalStart(e, 'brake'));
        brakeBtn.addEventListener('touchend', e => handlePedalEnd(e, 'brake'));
        brakeBtn.addEventListener('touchcancel', e => handlePedalEnd(e, 'brake'));
        
        handbrakeBtn.addEventListener('touchstart', e => handlePedalStart(e, 'handbrake'));
        handbrakeBtn.addEventListener('touchend', e => handlePedalEnd(e, 'handbrake'));
        handbrakeBtn.addEventListener('touchcancel', e => handlePedalEnd(e, 'handbrake'));
        
        nitroBtn.addEventListener('touchstart', e => handlePedalStart(e, 'nitro'));
        nitroBtn.addEventListener('touchend', e => handlePedalEnd(e, 'nitro'));
        nitroBtn.addEventListener('touchcancel', e => handlePedalEnd(e, 'nitro'));
        
        // Mouse fallback for pedals
        gasBtn.addEventListener('mousedown', e => handlePedalStart(e, 'gas'));
        gasBtn.addEventListener('mouseup', e => handlePedalEnd(e, 'gas'));
        gasBtn.addEventListener('mouseleave', e => handlePedalEnd(e, 'gas'));
        
        brakeBtn.addEventListener('mousedown', e => handlePedalStart(e, 'brake'));
        brakeBtn.addEventListener('mouseup', e => handlePedalEnd(e, 'brake'));
        brakeBtn.addEventListener('mouseleave', e => handlePedalEnd(e, 'brake'));
        
        handbrakeBtn.addEventListener('mousedown', e => handlePedalStart(e, 'handbrake'));
        handbrakeBtn.addEventListener('mouseup', e => handlePedalEnd(e, 'handbrake'));
        handbrakeBtn.addEventListener('mouseleave', e => handlePedalEnd(e, 'handbrake'));
        
        nitroBtn.addEventListener('mousedown', e => handlePedalStart(e, 'nitro'));
        nitroBtn.addEventListener('mouseup', e => handlePedalEnd(e, 'nitro'));
        nitroBtn.addEventListener('mouseleave', e => handlePedalEnd(e, 'nitro'));
        
        // Adaptive steering sensitivity: scale with screen width
        function getSteerSensitivity() {
            return Math.max(60, Math.min(120, window.innerWidth * 0.15));
        }

        // Steering touch
        steerZone.addEventListener('touchstart', e => {
            e.preventDefault();
            if (steerTouchId === null) {
                const touch = e.changedTouches[0];
                steerTouchId = touch.identifier;
                steerStartX = touch.clientX;
            }
        });

        steerZone.addEventListener('touchmove', e => {
            e.preventDefault();
            const sensitivity = getSteerSensitivity();
            for (let touch of e.changedTouches) {
                if (touch.identifier === steerTouchId) {
                    const dx = touch.clientX - steerStartX;
                    state.steering = Math.max(-1, Math.min(1, dx / sensitivity));
                    steerThumb.style.left = (50 + state.steering * 35) + '%';
                }
            }
        });

        steerZone.addEventListener('touchend', e => {
            for (let touch of e.changedTouches) {
                if (touch.identifier === steerTouchId) {
                    steerTouchId = null;
                    state.steering = 0;
                    steerThumb.style.left = '50%';
                }
            }
        });
        
        // Keyboard controls (desktop)
        const keys = {};
        window.addEventListener('keydown', e => { 
            keys[e.code] = true;
            // Reset car on R key
            if (e.code === 'KeyR') {
                state.position.x = 155;
                state.position.z = 0;
                state.rotation = Math.PI / 2;
                state.velocity.x = 0;
                state.velocity.z = 0;
                state.speed = 0;
                state.gear = 1;
            }
        });
        window.addEventListener('keyup', e => { keys[e.code] = false; });
        
        function updateKeyboardInput() {
            if (keys['KeyW'] || keys['ArrowUp']) state.throttle = 1;
            else if (!gasBtn.classList.contains('active')) state.throttle = 0;
            
            if (keys['KeyS'] || keys['ArrowDown']) state.brake = 1;
            else if (!brakeBtn.classList.contains('active')) state.brake = 0;
            
            if (keys['Space']) state.handbrake = 1;
            else if (!handbrakeBtn.classList.contains('active')) state.handbrake = 0;
            
            if (keys['ShiftLeft'] || keys['ShiftRight']) state.nitroActive = true;
            else if (!nitroBtn.classList.contains('active')) state.nitroActive = false;
            
            if (keys['KeyA'] || keys['ArrowLeft']) {
                state.steering = Math.max(-1, state.steering - 0.06);
            } else if (keys['KeyD'] || keys['ArrowRight']) {
                state.steering = Math.min(1, state.steering + 0.06);
            } else if (steerTouchId === null) {
                state.steering *= 0.9; // Return to center
            }
            steerThumb.style.left = (50 + state.steering * 35) + '%';
        }
        
        // ============================================
        // PACEJKA TIRE MODEL (for drift detection only)
        // ============================================
        function pacejka(slipAngle, load) {
            const t = CONFIG.tire;
            const x = slipAngle;
            const Bx = t.B * x;
            const force = load * t.D * Math.sin(t.C * Math.atan(Bx - t.E * (Bx - Math.atan(Bx))));
            return force * t.gripCoeff;
        }
        
        // ============================================
        // PHYSICS UPDATE (Fixed Timestep) - Simple Bicycle Model
        // ============================================
        const dt = 1 / CONFIG.physics.tickRate;
        
        function physicsStep() {
            const v = CONFIG.vehicle;
            
            // Store previous state for interpolation
            state.prevPosition.x = state.position.x;
            state.prevPosition.z = state.position.z;
            state.prevRotation = state.rotation;
            
            // Calculate forward/right vectors
            const forwardX = Math.sin(state.rotation);
            const forwardZ = Math.cos(state.rotation);
            
            // Speed (velocity projected onto forward direction)
            state.speed = state.velocity.x * forwardX + state.velocity.z * forwardZ;
            
            // Lateral speed (velocity projected onto right direction)
            const rightX = Math.cos(state.rotation);
            const rightZ = -Math.sin(state.rotation);
            state.lateralSpeed = state.velocity.x * rightX + state.velocity.z * rightZ;
            
            // ---- ENGINE & TRANSMISSION ----
            const wheelRadius = 0.35;
            const gearRatio = CONFIG.gears[state.gear - 1] * CONFIG.finalDrive;
            const wheelRPM = Math.abs(state.speed) / wheelRadius * 60 / (2 * Math.PI);
            state.rpm = Math.max(v.idleRPM, Math.min(v.maxRPM, wheelRPM * gearRatio));
            
            // Auto shift
            if (state.rpm > v.maxRPM * 0.9 && state.gear < CONFIG.gears.length) {
                state.gear++;
            } else if (state.rpm < v.idleRPM * 1.5 && state.gear > 1) {
                state.gear--;
            }
            
            // Torque (simplified HP to force)
            const torqueMult = 1 - Math.pow((state.rpm - 4500) / 4500, 2) * 0.3;
            const engineTorque = (v.power * 745.7 / (state.rpm * Math.PI / 30)) * torqueMult;
            
            // Nitro boost
            const n = CONFIG.nitro;
            let powerMult = 1;
            if (state.nitroActive && state.nitroAmount > n.minToActivate && state.throttle > 0) {
                powerMult = n.powerMult;
                state.nitroAmount = Math.max(0, state.nitroAmount - n.useRate * dt);
            } else {
                state.nitroAmount = Math.min(n.maxAmount, state.nitroAmount + n.rechargeRate * dt);
            }
            
            // ---- REVERSE GEAR LOGIC ----
            // Enter reverse: stopped (or nearly) + holding brake + not on gas
            if (Math.abs(state.speed) < 0.5 && state.brake > 0 && state.throttle === 0) {
                state.reversing = true;
            }
            // Exit reverse: gas pressed or brake released
            if (state.throttle > 0 || state.brake === 0) {
                state.reversing = false;
            }

            let driveForce, brakeDecel;

            if (state.reversing) {
                // In reverse: brake pedal drives backward at reduced power
                const reversePower = 0.35;
                const reverseWheelTorque = engineTorque * CONFIG.gears[0] * CONFIG.finalDrive * state.brake * reversePower;
                driveForce = -(reverseWheelTorque / wheelRadius);
                brakeDecel = 0;
            } else {
                const wheelTorque = engineTorque * gearRatio * state.throttle * powerMult;
                driveForce = wheelTorque / wheelRadius;
                brakeDecel = v.brakeForce * state.brake * Math.sign(state.speed);
            }

            // Handbrake (rear wheel lock - adds lateral instability)
            const handbrakeForce = v.handbrakeForce * state.handbrake * Math.sign(state.speed);

            // Drag & rolling resistance
            const dragForce = 0.5 * 1.2 * v.dragCoeff * 2.2 * state.speed * Math.abs(state.speed);
            const rollingForce = v.rollingResistance * v.mass * 9.81 * Math.sign(state.speed);

            // Net force along forward axis
            const netForce = driveForce - brakeDecel - handbrakeForce - dragForce - rollingForce;
            const accel = netForce / v.mass;

            // Update speed
            state.speed += accel * dt;

            // Prevent rolling when stopped and not inputting
            if (Math.abs(state.speed) < 0.1 && state.throttle === 0 && !state.reversing) {
                state.speed = 0;
            }
            
            // ---- STEERING (Simple Bicycle Model) ----
            const steerAngle = state.steering * v.maxSteerAngle * (1 - Math.min(1, Math.abs(state.speed) / 40) * 0.6);
            
            if (Math.abs(state.speed) > 0.5) {
                const turnRadius = v.wheelbase / Math.tan(Math.abs(steerAngle) + 0.001);
                // Negative sign: Three.js Y rotation is CCW, we want CW for right turn
                let angularVel = -state.speed / turnRadius * Math.sign(steerAngle);
                
                // Handbrake increases rotation (rear end slides out)
                if (state.handbrake > 0 && Math.abs(state.speed) > 3) {
                    const handbrakeRotation = state.steering * state.handbrake * 1.5 * Math.min(1, Math.abs(state.speed) / 15);
                    angularVel -= handbrakeRotation;
                }
                
                state.rotation += angularVel * dt;
            }
            
            // Update velocity vector (aligned with heading)
            state.velocity.x = Math.sin(state.rotation) * state.speed;
            state.velocity.z = Math.cos(state.rotation) * state.speed;
            
            // Update position
            state.position.x += state.velocity.x * dt;
            state.position.z += state.velocity.z * dt;
            
            // Check collisions
            checkCollisions();
            
            // ---- DRIFT DETECTION ----
            state.driftAngle = Math.abs(Math.atan2(state.lateralSpeed, Math.abs(state.speed) + 0.1));
            // Easier to trigger drift with handbrake
            const driftThreshold = state.handbrake > 0 ? 0.08 : 0.15;
            state.isDrifting = (state.driftAngle > driftThreshold && Math.abs(state.speed) > 5) || 
                               (state.handbrake > 0 && Math.abs(state.steering) > 0.3 && Math.abs(state.speed) > 8);
            
            state.physicsCount++;
        }
        
        // ============================================
        // RENDER LOOP (with interpolation)
        // ============================================
        function render(alpha, frameDt) {
            // Interpolate position
            const interpX = state.prevPosition.x + (state.position.x - state.prevPosition.x) * alpha;
            const interpZ = state.prevPosition.z + (state.position.z - state.prevPosition.z) * alpha;
            
            // Interpolate rotation (handle wrap-around)
            let rotDiff = state.rotation - state.prevRotation;
            if (rotDiff > Math.PI) rotDiff -= 2 * Math.PI;
            if (rotDiff < -Math.PI) rotDiff += 2 * Math.PI;
            const interpRot = state.prevRotation + rotDiff * alpha;
            
            // Update car mesh
            carGroup.position.x = interpX;
            carGroup.position.z = interpZ;
            carGroup.rotation.y = interpRot;
            
            // Body roll effect based on lateral force
            carGroup.rotation.z = -state.steering * 0.05 * Math.min(1, Math.abs(state.speed) / 20);
            
            // Camera follow (chase cam)
            const camDist = 14;
            const camHeight = 6;
            const camX = interpX - Math.sin(interpRot) * camDist;
            const camZ = interpZ - Math.cos(interpRot) * camDist;
            
            camera.position.set(camX, camHeight, camZ);
            camera.lookAt(interpX, 1, interpZ);
            
            // Update smoke particles
            updateSmoke(frameDt);
            
            // Render
            renderer.render(scene, camera);
            state.frameCount++;
        }
        
        // ============================================
        // HUD UPDATE
        // ============================================
        const speedEl = document.getElementById('speed');
        const rpmEl = document.getElementById('rpm');
        const gearEl = document.getElementById('gear');
        const fpsEl = document.getElementById('fps');
        const driftEl = document.getElementById('drift-indicator');
        const handbrakeEl = document.getElementById('handbrake-indicator');
        const nitroBar = document.getElementById('nitro-bar');
        
        // Minimap setup
        const minimapCanvas = document.getElementById('minimap');
        const minimapCtx = minimapCanvas.getContext('2d');
        const mapScale = 0.3; // world units to pixels
        const mapCenterX = minimapCanvas.width / 2;
        const mapCenterY = minimapCanvas.height / 2;
        
        function updateMinimap() {
            const ctx = minimapCtx;
            ctx.clearRect(0, 0, minimapCanvas.width, minimapCanvas.height);
            
            // Draw tracks (simplified circles)
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 8;
            ctx.beginPath();
            ctx.arc(mapCenterX, mapCenterY, 155 * mapScale, 0, Math.PI * 2);
            ctx.stroke();
            
            ctx.lineWidth = 6;
            ctx.beginPath();
            ctx.arc(mapCenterX, mapCenterY, 65 * mapScale, 0, Math.PI * 2);
            ctx.stroke();
            
            // Draw buildings as squares
            ctx.fillStyle = '#445';
            buildings.forEach(b => {
                const bx = mapCenterX + b.x * mapScale;
                const bz = mapCenterY + b.z * mapScale;
                ctx.fillRect(bx - 3, bz - 3, 6, 6);
            });
            
            // Draw car position
            const carMapX = mapCenterX + state.position.x * mapScale;
            const carMapZ = mapCenterY + state.position.z * mapScale;
            
            ctx.save();
            ctx.translate(carMapX, carMapZ);
            ctx.rotate(-state.rotation + Math.PI / 2);
            
            // Car triangle
            ctx.fillStyle = '#0ff';
            ctx.beginPath();
            ctx.moveTo(0, -5);
            ctx.lineTo(-3, 4);
            ctx.lineTo(3, 4);
            ctx.closePath();
            ctx.fill();
            
            ctx.restore();
        }
        
        let hudFrameCounter = 0;
        const hudUpdateInterval = isLowEnd ? 3 : 1; // Update HUD every N frames on low-end

        function updateHUD() {
            hudFrameCounter++;
            if (isLowEnd && hudFrameCounter % hudUpdateInterval !== 0) return;

            speedEl.textContent = Math.abs(Math.round(state.speed * 2.237)); // m/s to mph
            rpmEl.textContent = Math.round(state.rpm);
            gearEl.textContent = state.reversing ? 'R' : state.gear;
            driftEl.style.display = state.isDrifting ? 'block' : 'none';
            handbrakeEl.style.display = state.handbrake > 0 ? 'block' : 'none';
            nitroBar.style.width = (state.nitroAmount / CONFIG.nitro.maxAmount * 100) + '%';

            // Nitro bar color when low
            if (state.nitroAmount < CONFIG.nitro.minToActivate) {
                nitroBar.style.background = '#666';
            } else if (state.nitroActive && state.throttle > 0) {
                nitroBar.style.background = 'linear-gradient(90deg, #f0f, #ff0)';
            } else {
                nitroBar.style.background = 'linear-gradient(90deg, #0ff, #f0f)';
            }

            // Update minimap (throttled on low-end)
            if (!isLowEnd || hudFrameCounter % 2 === 0) {
                updateMinimap();
            }
        }
        
        function updateFPS(time) {
            if (time - state.lastFPSUpdate > 500) {
                const elapsed = (time - state.lastFPSUpdate) / 1000;
                fpsEl.textContent = Math.round(state.frameCount / elapsed);
                state.frameCount = 0;
                state.physicsCount = 0;
                state.lastFPSUpdate = time;
            }
        }
        
        // ============================================
        // MAIN GAME LOOP
        // ============================================
        function gameLoop(currentTime) {
            requestAnimationFrame(gameLoop);
            
            if (state.lastTime === 0) {
                state.lastTime = currentTime;
                state.lastFPSUpdate = currentTime;
            }
            
            const frameTime = Math.min((currentTime - state.lastTime) / 1000, 0.1);
            state.lastTime = currentTime;
            
            // Update keyboard input
            updateKeyboardInput();
            
            // Fixed timestep physics with accumulator
            state.accumulator += frameTime;
            let steps = 0;
            
            while (state.accumulator >= dt && steps < CONFIG.physics.maxSubSteps) {
                physicsStep();
                state.accumulator -= dt;
                steps++;
            }
            
            // Interpolation alpha (how far between physics steps)
            const alpha = state.accumulator / dt;
            
            // Render with interpolation
            render(alpha, frameTime);
            
            // Update HUD
            updateHUD();
            updateFPS(currentTime);
        }
        
        // ============================================
        // RESET CAR FUNCTION
        // ============================================
        function resetCar() {
            state.position.x = 155;
            state.position.z = 0;
            state.rotation = Math.PI / 2;
            state.velocity.x = 0;
            state.velocity.z = 0;
            state.speed = 0;
            state.gear = 1;
            vibrate(50);
        }

        // Mobile reset button
        if (isMobile) {
            resetBtn.style.display = 'block';
            resetBtn.addEventListener('touchstart', e => {
                e.preventDefault();
                resetCar();
            });
            resetBtn.addEventListener('mousedown', e => {
                e.preventDefault();
                resetCar();
            });
        }

        // ============================================
        // FULLSCREEN API (mobile)
        // ============================================
        function requestFullscreen() {
            const el = document.documentElement;
            const rfs = el.requestFullscreen || el.webkitRequestFullscreen || el.mozRequestFullScreen || el.msRequestFullscreen;
            if (rfs) {
                rfs.call(el).catch(() => {});
            }
            // Also try to lock to landscape
            if (screen.orientation && screen.orientation.lock) {
                screen.orientation.lock('landscape').catch(() => {});
            }
        }

        if (isMobile) {
            fullscreenPrompt.style.display = 'flex';
            fsBtn.addEventListener('click', () => {
                fullscreenPrompt.style.display = 'none';
                requestFullscreen();
            });
            // Also dismiss on any touch
            fullscreenPrompt.addEventListener('touchstart', e => {
                if (e.target === fullscreenPrompt) {
                    fullscreenPrompt.style.display = 'none';
                    requestFullscreen();
                }
            });
        }

        // ============================================
        // ORIENTATION HANDLING (mobile)
        // ============================================
        function checkOrientation() {
            if (!isMobile) return;
            const isPortrait = window.innerHeight > window.innerWidth;
            orientationWarning.style.display = isPortrait ? 'flex' : 'none';
        }
        checkOrientation();
        window.addEventListener('orientationchange', () => setTimeout(checkOrientation, 100));

        // ============================================
        // WAKE LOCK (prevent screen sleep)
        // ============================================
        let wakeLock = null;
        async function requestWakeLock() {
            if ('wakeLock' in navigator) {
                try {
                    wakeLock = await navigator.wakeLock.request('screen');
                    wakeLock.addEventListener('release', () => { wakeLock = null; });
                } catch (e) { /* Wake lock not available */ }
            }
        }
        if (isMobile) {
            requestWakeLock();
            document.addEventListener('visibilitychange', () => {
                if (document.visibilityState === 'visible') requestWakeLock();
            });
        }

        // ============================================
        // COLLISION HAPTIC FEEDBACK
        // ============================================
        const origCheckCollisions = checkCollisions;
        checkCollisions = function() {
            const hit = origCheckCollisions();
            if (hit) vibrate([30, 20, 30]);
            return hit;
        };

        // ============================================
        // RESIZE HANDLER
        // ============================================
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            checkOrientation();
        });

        // ============================================
        // VISIBILITY CHANGE (pause when hidden)
        // ============================================
        document.addEventListener('visibilitychange', () => {
            if (document.visibilityState === 'hidden') {
                // Reset timing so we don't get a huge dt spike on resume
                state.lastTime = 0;
                state.accumulator = 0;
            }
        });

        // ============================================
        // START
        // ============================================
        console.log('VOXEL FURY v2 - Core Engine Initialized' + (isMobile ? ' (Mobile Mode)' : ''));
        requestAnimationFrame(gameLoop);
        
    })();
    </script>
</body>
</html>
